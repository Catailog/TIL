# 2025-12-09 TIL

## 오늘 배운 것

- 자바스크립트 regex, 최적화
- DocumentFragment는 메모리에만 존재하는 가상의 DOM 컨테이너이다. `<></>`와 같이 이름이 없는 태그이며, 리액트에서도 흔히 사용된다. 효율적인 DOM 조작에 도움이 된다. 가상의 DOM에 HTML 노드들을 추가할 때 리플로우(reflow, 레이아웃 계산), 리페인트(repaint, 화면 다시 그리기)가 발생하지 않는다. 따라서 가상의 DOM에 모두 추가한 후 한꺼번에 DOM으로 옮기면 효율적으로 렌더링 할 수 있다.
- DocumentFragment를 사용하지 않는 경우가 더 효율적으로 보이거나 성능 차이가 거의 없는 것으로 보이는 경우가 있다. 이는 개발자가 비효율적인 코드를 작성하더라도 엔진이 이를 감지하고 자체적으로 최적화를 수행하는 경우가 있기 때문이다. 그럼에도 불구하고 DocumentFragment를 사용하는 것이 권장되는 이유는 예측 가능하고 일관된 성능을 보장하기 때문이다. 만약 루프 안에서 DOM의 크기나 위치를 읽는 코드가 단 한 줄이라도 추가되면 브라우저는 정확한 값을 계산하기 위해 최적화를 포기하고 리플로우를 실행한다. 이런 현상을 '강제 동기 레이아웃(Forced Synchronous Layout = Forced Reflow, 브라우저가 즉시 레이아웃 계산을 강제로 실행하는 이벤트)' 또는 '레이아웃 스래싱(Layout Thrashing, Forced Synchronous Layout이 반복적으로 여러 번 발생하는 패턴)'이라 한다.

```js
// 개선 전후 차이: 브라우저가 box.offsetWidth를 다시 계산하려 하지 않는다.
// 비효율적인 버전
function resizeAllParagraphsToMatchBlockWidth() {
  // Puts the browser into a read-write-read-write cycle.
  for (let i = 0; i < paragraphs.length; i++) {
    paragraphs[i].style.width = `${box.offsetWidth}px`;
  }
}

// 효율적인 버전
// Read.
const width = box.offsetWidth;

function resizeAllParagraphsToMatchBlockWidth() {
  for (let i = 0; i < paragraphs.length; i++) {
    // Now write.
    paragraphs[i].style.width = `${width}px`;
  }
}
```

- 연속적으로 발생하는 이벤트들마다 함수를 호출하지 않고, 특정 시간(delay)이 지난 후 마지막 이벤트에 대한 함수를 한 번만 호출하는 기법을 debounce라 한다.
- throttle은 debounce와 유사하게 연속적인 이벤트에 따른 함수 호출 횟수를 제한하지만 일정 시간 간격으로 최대 1회 호출한다는 차이가 있다.
