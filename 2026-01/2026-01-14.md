# 2026-01-14 TIL

## 오늘 배운 것

- Code Splitting, useCallback, 조건부 렌더링, useEffect
- lazy 함수는 당장 필요 하지 않은 컴포넌트를 나중에 불러와서 번들 크기를 줄이고 초기 로딩을 빠르게 할 때 사용한다. 이를 코드 분할(Code Splitting)이라 한다. lazy 컴포넌트는 Suspense 컴포넌트 하위에서 렌더링되어야 한다.

```tsx
import React, { Suspense } from "react";

const OtherComponent = React.lazy(() => import("./OtherComponent"));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

- useCallback은 의존성 배열이 변하지 않는 한 동일한 함수 참조를 유지해
  함수의 불필요한 재생성을 방지하는 데 사용한다. 이때 의존성 배열로 빈 배열을 사용하면 콜백 함수는 최초 렌더링 시의 state 값을 참조한 채 유지된다. 의존성 배열의 변경 여부에 따라 이전 값을 재사용할지 결정하는 것을 메모이제이션(memoization)이라 한다.

```tsx
const memoizedFunc = useCallback(
  () => {
    // ...
  },
  [
    /* deps... */
  ]
);
```

- useCallback이 함수를 메모이제이션한다면, useMemo는 계산된 값을 메모이제이션한다. 값 계산에 비용이 큰 연산이 있을 때 사용하기 적합하다.

```tsx
const filteredList = useMemo(() => {
  return list.filter((item) => item.score > 80);
}, [list]);
```

- 조건부 렌더링에서 &&는 UI 토글, ||는 fallback에 많이 사용된다. 사용 시 0이나 "" 같은 값 또한 false라는 점에 유의하여 사용해야 한다.
- useEffect는 컴포넌트 렌더링 외에 실행되어야 하는 작업(부수 효과)을 처리하기 위해 사용한다. 2번째 인자로 빈 배열을 넣어 마운트 시에만 실행되도록 할 수도 있다. 컴포넌트가 화면에 렌더링된 뒤 실행되므로, API 요청, 이벤트 등록 등 화면 렌더링과 독립적인 작업을 처리할 때 적합하다.
- useEffect는 함수를 반환할 수 있는데 이 함수를 '정리(cleanup) 함수'라고 한다. 이 함수는 컴포넌트가 언마운트될 때 또는 다음 effect가 실행되기 직전(deps 유무에 따름)에 호출된다. 메모리 누수를 방지하기 위해 사용한다.

```tsx
const [count, setCount] = useState(0);

useEffect(() => {
  console.log("count가 바뀔 때마다 실행됨");
}, [count]);
useEffect(() => {
  console.log("마운트 될 때만 실행됨");
  return () => {
    console.log("언마운트 될 때만 실행됨");
  };
}, []);
```
