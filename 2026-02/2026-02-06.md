# 2026-02-06 TIL

## 오늘 배운 것

- Firestore onSnapshot, TanStack Query, 무한 스크롤

- 실시간 리스너 onSnapshot은 1번 구독해놓으면 서버의 데이터가 변경될 때마다 자동으로 받아온다.

```tsx
import { onSnapshot, query, orderBy, collection } from "firebase/firestore";

const q = query(collection(db, "posts"), orderBy("createdAt", "desc"));

// 구독 후 구독 해제 함수를 반환 받음
const unsubscribe = onSnapshot(q, (snapshot) => {
  const posts = snapshot.docs.map((doc) => ({
    id: doc.id,
    ...doc.data(),
  }));
});
```

- 무한 스크롤은 IntersectionObserver를 이용하여 구현할 수 있다.

```tsx
const observerRef = useRef<IntersectionObserver | null>(null);
const loadMoreRef = useRef<HTMLDivElement>(null);

const handleObserver = useCallback(
  (entries: IntersectionObserverEntry[]) => {
    const target = entries[0];
    if (target.isIntersecting && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  },
  [fetchNextPage, hasNextPage, isFetchingNextPage],
);

useEffect(() => {
  const element = loadMoreRef.current;
  if (!element) return;

  observerRef.current = new IntersectionObserver(handleObserver, {
    threshold: 0.1,
  });

  observerRef.current.observe(element);

  return () => {
    if (observerRef.current) {
      observerRef.current.disconnect();
    }
  };
}, [handleObserver]);
```

- 전체의 0.1(10%)만 화면에 보여도(intersection, 화면과의 교차) fetchNextPage를 실행하는 코드이다. 감시 대상은 loadMoreRef, 감시를 위한 조건들을 보유한 감시자는 observerRef이다.

- 타입스크립트는 구조적 타입 시스템(structural typing: 이름이 무엇이든, 내부 구성 요소(구조)가 같으면 같은 타입으로 인정)이다.

```tsx
interface Vector2D {
  x: number;
  y: number;
}

interface Point {
  x: number;
  y: number;
}

function printLocation(location: Vector2D) {
  console.log(`위치: ${location.x}, ${location.y}`);
}

const myPoint: Point = { x: 10, y: 20 };

printLocation(myPoint); // 에러가 발생하지 않음
```

- 이로 인해 객체로 분리된 옵션에서 오타나 잘못된 프로퍼티 사용 시 타입 에러가 발생하지 않는 문제가 있다.

```tsx
useQuery({
  queryKey: todokeys.all,
  queryFn: fetchTodos,
  stallTime: 5000, // staleTime의 오타 - 타입 에러 발생
});

const todosQuery = {
  queryKey: todokeys.all,
  queryFn: fetchTodos,
  stallTime: 5000, // staleTime의 오타
};

useQuery(todosQuery); // 타입 에러가 발생하지 않음
```

- 이를 방지하기 위해 TanStack Query v5에서는 queryOptions가 도입되었다. 기존 Query Key Factory 패턴 대신 Query Factory 패턴 사용을 권장하고 있다. [공식 블로그](https://tkdodo.eu/blog/the-query-options-api)

```tsx
const todoQueries = {
  all: () => ["todos"],
  lists: () => [...todoQueries.all(), "list"],
  list: (filters: string) =>
    queryOptions({
      queryKey: [...todoQueries.lists(), filters],
      queryFn: () => fetchTodos(filters),
    }),
  details: () => [...todoQueries.all(), "detail"],
  detail: (id: number) =>
    queryOptions({
      queryKey: [...todoQueries.details(), id],
      queryFn: () => fetchTodo(id),
      staleTime: 5000,
    }),
};
```
